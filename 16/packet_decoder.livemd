<!-- livebook:{"persist_outputs":true} -->

# DÃ­a 16: Packet Decoder

## Input data

<!-- livebook:{"livebook_object":"cell_input","name":"data","type":"textarea","value":"C200B40A82,04005AC33890,880086C3E88112,CE00C43D881120,D8005AC2A8F0,F600BC2D8F,9C005AC2F8F0,9C0141080250320F1802104A08,0054FEC8C54DC02295D5AE9B243D2F4FEA154493A43E0E60084E61CE802419A95E38958DE4F100B9708300466AB2AB7D80291DA471EB9110010328F820084D5742D2C8E600AC8DF3DBD486C010999B44CCDBD401C9BBCE3FD3DCA624652C400007FC97B113B8C4600A6002A33907E9C83ECB4F709FD51400B3002C4009202E9D00AF260290D400D70038400E7003C400A201B01400B401609C008201115003915002D002525003A6EB49C751ED114C013865800BFCA234E677512952E20040649A26DFA1C90087D600A8803F0CA1AC1F00042A3E41F8D31EE7C8D800FD97E43CCE401A9E802D377B5B751A95BCD3E574124017CF00341353E672A32E2D2356B9EE79088032AF005E7E8F33F47F95EC29AD3018038000864658471280010C8FD1D63C080390E61D44600092645366202933C9FA2F460095006E40008742A8E70F80010F8DF0AA264B331004C52B647D004E6EEF534C8600BCC93E802D38B5311AC7E7B02D804629DD034DFBB1E2D4E2ACBDE9F9FF8ED2F10099DE828803C7C0068E7B9A7D9EE69F263B7D427541200806582E49725CFA64240050A20043E25C148CC600F45C8E717C8010E84506E1F18023600A4D934DC379B9EC96B242402504A027006E200085C6B8D51200010F89913629A805925FBD3322191A1C45A9EACB4733FBC5631A210805315A7E3BC324BCE8573ACF3222600BCD6B3997E7430F004E37CED091401293BEAC2D138402496508873967A840E00E41E99DE6B9D3CCB5E3F9A69802B2368E7558056802E200D4458AF1180010A82B1520DB80212588014C009803B2A3134DD32706009498C600664200F4558630F840188E11EE3B200C292B59124AFF9AE6775ED8BE73D4FEEFFAD4CE7E72FFBB7BB49005FB3BEBFA84140096CD5FEDF048C011B004A5B327F96CC9E653C9060174EA0CF15CA0E4D044F9E4B6258A5065400D9B68"} -->

```elixir
inputs =
  IO.gets("data")
  |> String.trim_trailing()
  |> String.split(",")
  |> Enum.map(fn input ->
    data =
      input
      |> String.to_integer(16)
      |> Integer.to_string(2)

    # nos aseguramos de que la lÃ­nea contenga todos los bits de los bytes
    String.pad_leading(data, String.length(input) * 4, "0")
  end)
```

```output
["1100001000000000101101000000101010000010", "000001000000000001011010110000110011100010010000",
 "10001000000000001000011011000011111010001000000100010010",
 "11001110000000001100010000111101100010000001000100100000",
 "110110000000000001011010110000101010100011110000", "1111011000000000101111000010110110001111",
 "100111000000000001011010110000101111100011110000",
 "10011100000000010100000100001000000000100101000000110010000011110001100000000010000100000100101000001000",
 "0000000001010100111111101100100011000101010011011100000000100010100101011101010110101110100110110010010000111101001011110100111111101010000101010100010010010011101001000011111000001110011000000000100001001110011000011100111010000000001001000001100110101001010111100011100010010101100011011110010011110001000000001011100101110000100000110000000001000110011010101011001010101011011111011000000000101001000111011010010001110001111010111001000100010000000000010000001100101000111110000010000000001000010011010101011101000010110100101100100011100110000000001010110010001101111100111101101111010100100001101100000000010000100110011001101101000100110011001101101111010100000000011100100110111011110011100011111111010011110111001010011000100100011001010010110001000000000000000000011111111100100101111011000100010011101110001100010001100000000010100110000000000010101000110011100100000111111010011100100000111110110010110100111101110000100111111101010100010100000000001011001100000000001011000100000000001001001000000010111010011101000000001010111100100110000000101001000011010100000000001101011100000000001110000100000000001110011100000000001111000100000000001010001000000001101100000001010000000000101101000000000101100000100111000000000010000010000000010001000101010000000000111001000101010000000000101101000000000010010100100101000000000011101001101110101101001001110001110101000111101101000100010100110000000001001110000110010110000000000010111111110010100010001101001110011001110111010100010010100101010010111000100000000001000000011001001001101000100110110111111010000111001001000000001000011111010110000000001010100010000000001111110000110010100001101011000001111100000000000001000010101000111110010000011111100011010011000111101110011111001000110110000000000011111101100101111110010000111100110011100100000000011010100111101000000000101101001101110111101101011011011101010001101010010101101111001101001111100101011101000001001001000000000101111100111100000000001101000001001101010011111001100111001010100011001011100010110100100011010101101011100111101110011110010000100010000000001100101010111100000000010111100111111010001111001100111111010001111111100101011110110000101001101011010011000000011000000000111000000000000000100001100100011001011000010001110001001010000000000000010000110010001111110100011101011000111100000010000000001110010000111001100001110101000100011000000000000010010010011001000101001101100110001000000010100100110011110010011111101000101111010001100000000010010101000000000110111001000000000000001000011101000010101010001110011100001111100000000000000100001111100011011111000010101010001001100100101100110011000100000000010011000101001010110110010001111101000000000100111001101110111011110101001101001100100001100000000010111100110010010011111010000000001011010011100010110101001100010001101011000111111001111011000000101101100000000100011000101001110111010000001101001101111110111011000111100010110101001110001010101100101111011110100111111001111111111000111011010010111100010000000010011001110111101000001010001000000000111100011111000000000001101000111001111011100110100111110110011110111001101001111100100110001110110111110101000010011101010100000100100000000010000000011001011000001011100100100101110010010111001111101001100100001001000000000001010000101000100000000001000011111000100101110000010100100011001100011000000000111101000101110010001110011100010111110010000000000100001110100001000101000001101110000111110001100000000010001101100000000010100100110110010011010011011100001101111001101110011110110010010110101100100100001001000000001001010000010010100000001001110000000001101110001000000000000010000101110001101011100011010101000100100000000000000001000011111000100110010001001101100010100110101000000001011001001001011111101111010011001100100010000110010001101000011100010001011010100111101010110010110100011100110011111110111100010101100011000110100010000100001000000001010011000101011010011111100011101111000011001001001011110011101000010101110011101011001111001100100010001001100000000010111100110101101011001110011001011111100111010000110000111100000000" <> ...]
```

## Puzzle 1

```elixir
defmodule Puzzle do
  def parse(string), do: parse(string, [])

  def parse(<<version::binary-size(3), "100", rest::binary()>>, acc) do
    {num, rest} = parse_literal(rest)
    version = String.to_integer(version, 2)
    {rest, [{:literal, version, num} | acc]}
  end

  def parse(
        <<
          version::binary-size(3),
          operation::binary-size(3),
          # length_type_id
          "0",
          total_length::binary-size(15),
          rest::binary()
        >>,
        acc
      ) do
    total_length = String.to_integer(total_length, 2)
    <<subpackets::binary-size(total_length), rest::binary()>> = rest
    {_, parsed_data} = parse_subpackets(subpackets)
    version = String.to_integer(version, 2)
    {rest, [{:operator, version, to_operation(operation), parsed_data} | acc]}
  end

  def parse(
        <<
          version::binary-size(3),
          operation::binary-size(3),
          # length_type_id
          "1",
          total_length::binary-size(11),
          rest::binary()
        >>,
        acc
      ) do
    total_length = String.to_integer(total_length, 2)
    {rest, parsed_data} = parse_n_subpackets(rest, total_length)
    version = String.to_integer(version, 2)
    {rest, [{:operator, version, to_operation(operation), parsed_data} | acc]}
  end

  defp parse_n_subpackets(string, n), do: parse_n_subpackets(string, n, [])
  defp parse_n_subpackets(string, 0, acc), do: {string, Enum.reverse(acc)}

  defp parse_n_subpackets(string, n, acc) do
    {rest, parsed_data} = parse(string, [])
    parse_n_subpackets(rest, n - 1, parsed_data ++ acc)
  end

  defp parse_subpackets(string), do: parse_subpackets(string, [])
  defp parse_subpackets(<<>>, acc), do: {<<>>, Enum.reverse(acc)}

  defp parse_subpackets(string, acc) do
    {rest, parsed_data} = parse(string, [])
    parse_subpackets(rest, parsed_data ++ acc)
  end

  defp parse_literal(string), do: parse_literal(string, 0)

  defp parse_literal(<<"1", bin_num::binary-size(4), rest::binary()>>, num) do
    parse_literal(rest, num * 0x10 + String.to_integer(bin_num, 2))
  end

  defp parse_literal(<<"0", bin_num::binary-size(4), rest::binary()>>, num) do
    {num * 0x10 + String.to_integer(bin_num, 2), rest}
  end

  def sum_versions(parsed_data), do: sum_versions(parsed_data, 0)
  def sum_versions([], sum), do: sum

  def sum_versions([{:operator, v, _operation, data} | rest], sum) do
    sum_versions(rest, v + sum_versions(data) + sum)
  end

  def sum_versions([{:literal, v, _num} | rest], sum) do
    sum_versions(rest, v + sum)
  end

  def apply_operations(operations), do: apply_operations(operations, [])

  defp apply_operations([], acc), do: acc

  defp apply_operations([op1 | rest], acc) do
    apply_operations(rest, [get_num(op1) | acc])
  end

  defp get_num({:operator, _v, f, data}), do: f.(data)
  defp get_num({:literal, _v, num}), do: num

  defp to_operation("000") do
    fn data -> Enum.reduce(data, 0, &(get_num(&1) + &2)) end
  end

  defp to_operation("001") do
    fn data -> Enum.reduce(data, 1, &(get_num(&1) * &2)) end
  end

  defp to_operation("010") do
    fn data -> Enum.reduce(data, nil, &min(get_num(&1), &2)) end
  end

  defp to_operation("011") do
    fn data -> Enum.reduce(data, 0, &max(get_num(&1), &2)) end
  end

  defp to_operation("101") do
    fn [op1, op2] -> to_num(get_num(op1) > get_num(op2)) end
  end

  defp to_operation("110") do
    fn [op1, op2] -> to_num(get_num(op1) < get_num(op2)) end
  end

  defp to_operation("111") do
    fn [op1, op2] -> to_num(get_num(op1) == get_num(op2)) end
  end

  defp to_num(true), do: 1
  defp to_num(false), do: 0
end

:ok
```

```output
:ok
```

## Sum of versions

```elixir
for data <- inputs do
  {_, parsed_data} = Puzzle.parse(data)
  Puzzle.sum_versions(parsed_data)
end
```

```output
[14, 8, 15, 11, 13, 19, 16, 20, 934]
```

## Apply operators

```elixir
for data <- inputs do
  {_, parsed_data} = Puzzle.parse(data)
  [result] = Puzzle.apply_operations(parsed_data)
  result
end
```

```output
[3, 54, 7, 9, 1, 0, 0, 1, 912901337844]
```
